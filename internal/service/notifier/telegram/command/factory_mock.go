// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package command

//go:generate minimock -i github.com/robertobadjio/tgtime-notifier/internal/service/notifier/telegram/command.Factory -o factory_mock.go -n FactoryMock -p command

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
	"github.com/gojuno/minimock/v3"
)

// FactoryMock implements Factory
type FactoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCommandHandler          func(update tgbotapi.Update) (c1 Command)
	funcGetCommandHandlerOrigin    string
	inspectFuncGetCommandHandler   func(update tgbotapi.Update)
	afterGetCommandHandlerCounter  uint64
	beforeGetCommandHandlerCounter uint64
	GetCommandHandlerMock          mFactoryMockGetCommandHandler
}

// NewFactoryMock returns a mock for Factory
func NewFactoryMock(t minimock.Tester) *FactoryMock {
	m := &FactoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCommandHandlerMock = mFactoryMockGetCommandHandler{mock: m}
	m.GetCommandHandlerMock.callArgs = []*FactoryMockGetCommandHandlerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFactoryMockGetCommandHandler struct {
	optional           bool
	mock               *FactoryMock
	defaultExpectation *FactoryMockGetCommandHandlerExpectation
	expectations       []*FactoryMockGetCommandHandlerExpectation

	callArgs []*FactoryMockGetCommandHandlerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FactoryMockGetCommandHandlerExpectation specifies expectation struct of the Factory.GetCommandHandler
type FactoryMockGetCommandHandlerExpectation struct {
	mock               *FactoryMock
	params             *FactoryMockGetCommandHandlerParams
	paramPtrs          *FactoryMockGetCommandHandlerParamPtrs
	expectationOrigins FactoryMockGetCommandHandlerExpectationOrigins
	results            *FactoryMockGetCommandHandlerResults
	returnOrigin       string
	Counter            uint64
}

// FactoryMockGetCommandHandlerParams contains parameters of the Factory.GetCommandHandler
type FactoryMockGetCommandHandlerParams struct {
	update tgbotapi.Update
}

// FactoryMockGetCommandHandlerParamPtrs contains pointers to parameters of the Factory.GetCommandHandler
type FactoryMockGetCommandHandlerParamPtrs struct {
	update *tgbotapi.Update
}

// FactoryMockGetCommandHandlerResults contains results of the Factory.GetCommandHandler
type FactoryMockGetCommandHandlerResults struct {
	c1 Command
}

// FactoryMockGetCommandHandlerOrigins contains origins of expectations of the Factory.GetCommandHandler
type FactoryMockGetCommandHandlerExpectationOrigins struct {
	origin       string
	originUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Optional() *mFactoryMockGetCommandHandler {
	mmGetCommandHandler.optional = true
	return mmGetCommandHandler
}

// Expect sets up expected params for Factory.GetCommandHandler
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Expect(update tgbotapi.Update) *mFactoryMockGetCommandHandler {
	if mmGetCommandHandler.mock.funcGetCommandHandler != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by Set")
	}

	if mmGetCommandHandler.defaultExpectation == nil {
		mmGetCommandHandler.defaultExpectation = &FactoryMockGetCommandHandlerExpectation{}
	}

	if mmGetCommandHandler.defaultExpectation.paramPtrs != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by ExpectParams functions")
	}

	mmGetCommandHandler.defaultExpectation.params = &FactoryMockGetCommandHandlerParams{update}
	mmGetCommandHandler.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommandHandler.expectations {
		if minimock.Equal(e.params, mmGetCommandHandler.defaultExpectation.params) {
			mmGetCommandHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommandHandler.defaultExpectation.params)
		}
	}

	return mmGetCommandHandler
}

// ExpectUpdateParam1 sets up expected param update for Factory.GetCommandHandler
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) ExpectUpdateParam1(update tgbotapi.Update) *mFactoryMockGetCommandHandler {
	if mmGetCommandHandler.mock.funcGetCommandHandler != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by Set")
	}

	if mmGetCommandHandler.defaultExpectation == nil {
		mmGetCommandHandler.defaultExpectation = &FactoryMockGetCommandHandlerExpectation{}
	}

	if mmGetCommandHandler.defaultExpectation.params != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by Expect")
	}

	if mmGetCommandHandler.defaultExpectation.paramPtrs == nil {
		mmGetCommandHandler.defaultExpectation.paramPtrs = &FactoryMockGetCommandHandlerParamPtrs{}
	}
	mmGetCommandHandler.defaultExpectation.paramPtrs.update = &update
	mmGetCommandHandler.defaultExpectation.expectationOrigins.originUpdate = minimock.CallerInfo(1)

	return mmGetCommandHandler
}

// Inspect accepts an inspector function that has same arguments as the Factory.GetCommandHandler
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Inspect(f func(update tgbotapi.Update)) *mFactoryMockGetCommandHandler {
	if mmGetCommandHandler.mock.inspectFuncGetCommandHandler != nil {
		mmGetCommandHandler.mock.t.Fatalf("Inspect function is already set for FactoryMock.GetCommandHandler")
	}

	mmGetCommandHandler.mock.inspectFuncGetCommandHandler = f

	return mmGetCommandHandler
}

// Return sets up results that will be returned by Factory.GetCommandHandler
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Return(c1 Command) *FactoryMock {
	if mmGetCommandHandler.mock.funcGetCommandHandler != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by Set")
	}

	if mmGetCommandHandler.defaultExpectation == nil {
		mmGetCommandHandler.defaultExpectation = &FactoryMockGetCommandHandlerExpectation{mock: mmGetCommandHandler.mock}
	}
	mmGetCommandHandler.defaultExpectation.results = &FactoryMockGetCommandHandlerResults{c1}
	mmGetCommandHandler.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommandHandler.mock
}

// Set uses given function f to mock the Factory.GetCommandHandler method
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Set(f func(update tgbotapi.Update) (c1 Command)) *FactoryMock {
	if mmGetCommandHandler.defaultExpectation != nil {
		mmGetCommandHandler.mock.t.Fatalf("Default expectation is already set for the Factory.GetCommandHandler method")
	}

	if len(mmGetCommandHandler.expectations) > 0 {
		mmGetCommandHandler.mock.t.Fatalf("Some expectations are already set for the Factory.GetCommandHandler method")
	}

	mmGetCommandHandler.mock.funcGetCommandHandler = f
	mmGetCommandHandler.mock.funcGetCommandHandlerOrigin = minimock.CallerInfo(1)
	return mmGetCommandHandler.mock
}

// When sets expectation for the Factory.GetCommandHandler which will trigger the result defined by the following
// Then helper
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) When(update tgbotapi.Update) *FactoryMockGetCommandHandlerExpectation {
	if mmGetCommandHandler.mock.funcGetCommandHandler != nil {
		mmGetCommandHandler.mock.t.Fatalf("FactoryMock.GetCommandHandler mock is already set by Set")
	}

	expectation := &FactoryMockGetCommandHandlerExpectation{
		mock:               mmGetCommandHandler.mock,
		params:             &FactoryMockGetCommandHandlerParams{update},
		expectationOrigins: FactoryMockGetCommandHandlerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommandHandler.expectations = append(mmGetCommandHandler.expectations, expectation)
	return expectation
}

// Then sets up Factory.GetCommandHandler return parameters for the expectation previously defined by the When method
func (e *FactoryMockGetCommandHandlerExpectation) Then(c1 Command) *FactoryMock {
	e.results = &FactoryMockGetCommandHandlerResults{c1}
	return e.mock
}

// Times sets number of times Factory.GetCommandHandler should be invoked
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Times(n uint64) *mFactoryMockGetCommandHandler {
	if n == 0 {
		mmGetCommandHandler.mock.t.Fatalf("Times of FactoryMock.GetCommandHandler mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommandHandler.expectedInvocations, n)
	mmGetCommandHandler.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommandHandler
}

func (mmGetCommandHandler *mFactoryMockGetCommandHandler) invocationsDone() bool {
	if len(mmGetCommandHandler.expectations) == 0 && mmGetCommandHandler.defaultExpectation == nil && mmGetCommandHandler.mock.funcGetCommandHandler == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommandHandler.mock.afterGetCommandHandlerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommandHandler.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommandHandler implements Factory
func (mmGetCommandHandler *FactoryMock) GetCommandHandler(update tgbotapi.Update) (c1 Command) {
	mm_atomic.AddUint64(&mmGetCommandHandler.beforeGetCommandHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommandHandler.afterGetCommandHandlerCounter, 1)

	mmGetCommandHandler.t.Helper()

	if mmGetCommandHandler.inspectFuncGetCommandHandler != nil {
		mmGetCommandHandler.inspectFuncGetCommandHandler(update)
	}

	mm_params := FactoryMockGetCommandHandlerParams{update}

	// Record call args
	mmGetCommandHandler.GetCommandHandlerMock.mutex.Lock()
	mmGetCommandHandler.GetCommandHandlerMock.callArgs = append(mmGetCommandHandler.GetCommandHandlerMock.callArgs, &mm_params)
	mmGetCommandHandler.GetCommandHandlerMock.mutex.Unlock()

	for _, e := range mmGetCommandHandler.GetCommandHandlerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.paramPtrs

		mm_got := FactoryMockGetCommandHandlerParams{update}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.update != nil && !minimock.Equal(*mm_want_ptrs.update, mm_got.update) {
				mmGetCommandHandler.t.Errorf("FactoryMock.GetCommandHandler got unexpected parameter update, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.expectationOrigins.originUpdate, *mm_want_ptrs.update, mm_got.update, minimock.Diff(*mm_want_ptrs.update, mm_got.update))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommandHandler.t.Errorf("FactoryMock.GetCommandHandler got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommandHandler.GetCommandHandlerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommandHandler.t.Fatal("No results are set for the FactoryMock.GetCommandHandler")
		}
		return (*mm_results).c1
	}
	if mmGetCommandHandler.funcGetCommandHandler != nil {
		return mmGetCommandHandler.funcGetCommandHandler(update)
	}
	mmGetCommandHandler.t.Fatalf("Unexpected call to FactoryMock.GetCommandHandler. %v", update)
	return
}

// GetCommandHandlerAfterCounter returns a count of finished FactoryMock.GetCommandHandler invocations
func (mmGetCommandHandler *FactoryMock) GetCommandHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommandHandler.afterGetCommandHandlerCounter)
}

// GetCommandHandlerBeforeCounter returns a count of FactoryMock.GetCommandHandler invocations
func (mmGetCommandHandler *FactoryMock) GetCommandHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommandHandler.beforeGetCommandHandlerCounter)
}

// Calls returns a list of arguments used in each call to FactoryMock.GetCommandHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommandHandler *mFactoryMockGetCommandHandler) Calls() []*FactoryMockGetCommandHandlerParams {
	mmGetCommandHandler.mutex.RLock()

	argCopy := make([]*FactoryMockGetCommandHandlerParams, len(mmGetCommandHandler.callArgs))
	copy(argCopy, mmGetCommandHandler.callArgs)

	mmGetCommandHandler.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommandHandlerDone returns true if the count of the GetCommandHandler invocations corresponds
// the number of defined expectations
func (m *FactoryMock) MinimockGetCommandHandlerDone() bool {
	if m.GetCommandHandlerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommandHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommandHandlerMock.invocationsDone()
}

// MinimockGetCommandHandlerInspect logs each unmet expectation
func (m *FactoryMock) MinimockGetCommandHandlerInspect() {
	for _, e := range m.GetCommandHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FactoryMock.GetCommandHandler at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommandHandlerCounter := mm_atomic.LoadUint64(&m.afterGetCommandHandlerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommandHandlerMock.defaultExpectation != nil && afterGetCommandHandlerCounter < 1 {
		if m.GetCommandHandlerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FactoryMock.GetCommandHandler at\n%s", m.GetCommandHandlerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FactoryMock.GetCommandHandler at\n%s with params: %#v", m.GetCommandHandlerMock.defaultExpectation.expectationOrigins.origin, *m.GetCommandHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommandHandler != nil && afterGetCommandHandlerCounter < 1 {
		m.t.Errorf("Expected call to FactoryMock.GetCommandHandler at\n%s", m.funcGetCommandHandlerOrigin)
	}

	if !m.GetCommandHandlerMock.invocationsDone() && afterGetCommandHandlerCounter > 0 {
		m.t.Errorf("Expected %d calls to FactoryMock.GetCommandHandler at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommandHandlerMock.expectedInvocations), m.GetCommandHandlerMock.expectedInvocationsOrigin, afterGetCommandHandlerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FactoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCommandHandlerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FactoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FactoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCommandHandlerDone()
}
